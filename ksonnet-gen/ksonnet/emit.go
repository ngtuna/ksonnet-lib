package ksonnet

import (
	"fmt"
	"log"
	"sort"
	"strings"

	"github.com/ksonnet/ksonnet-lib/ksonnet-gen/jsonnet"
	"github.com/ksonnet/ksonnet-lib/ksonnet-gen/kubespec"
	"github.com/ksonnet/ksonnet-lib/ksonnet-gen/kubeversion"
)

// Emit takes a swagger API specification, and returns the text of
// `ksonnet-lib`, written in Jsonnet.
func Emit(spec *kubespec.APISpec) ([]byte, error) {
	root := newRoot(spec)

	m := newIndentWriter()
	root.emit(m)
	return m.bytes()
}

//-----------------------------------------------------------------------------
// Root.
//-----------------------------------------------------------------------------

// `root` is an abstraction of the root of `k8s.libsonnet`, which can be
// emitted as Jsonnet code using the `emit` method.
//
// `root` contains and manages a set of `groups`, which represent a
// set of Kubernetes API groups (e.g., core, apps, extensions), and
// holds all of the logic required to build the `groups` from an
// `kubespec.APISpec`.
type root struct {
	spec   *kubespec.APISpec
	groups groupSet // set of groups, e.g., core, apps, extensions.
}

func newRoot(spec *kubespec.APISpec) *root {
	root := root{
		spec:   spec,
		groups: make(groupSet),
	}

	for defName, def := range spec.Definitions {
		root.addDefinition(defName, def)
	}

	return &root
}

func (root *root) emit(m *indentWriter) {
	m.writeLine("// AUTOGENERATED from the Kubernetes OpenAPI specification. DO NOT MODIFY.")
	m.writeLine(fmt.Sprintf("// Kubernetes version: %s", root.spec.Info.Version))
	m.writeLine(fmt.Sprintf(
		"// SHA of ksonnet-lib HEAD: %s", getSHARevision(".")))
	m.writeLine(fmt.Sprintf(
		"// SHA of Kubernetes HEAD OpenAPI spec is generated from: %s",
		getSHARevision(root.spec.FilePath)))
	m.writeLine("")

	m.writeLine("{")
	m.indent()

	// Emit in sorted order so that we can diff the output.
	for _, group := range root.groups.toSortedSlice() {
		group.emit(m)
	}

	m.dedent()
	m.writeLine("}")
}

func (root *root) addDefinition(
	path kubespec.DefinitionName, def *kubespec.SchemaDefinition,
) {
	parsedName := path.Parse()
	apiObject, err := root.createAPIObject(parsedName, def)
	if err != nil {
		return
	}

	for propName, prop := range def.Properties {
		pm := newPropertyMethod(propName, path, prop, apiObject)
		apiObject.propertyMethods[propName] = pm
	}
}

func (root *root) createAPIObject(
	parsedName *kubespec.ParsedDefinitionName, def *kubespec.SchemaDefinition,
) (*apiObject, error) {
	if parsedName.Version == nil {
		return nil, fmt.Errorf(
			"Can't make API object from name with nil version in path: '%s'",
			parsedName.Unparse())
	}

	var groupName kubespec.GroupName
	if parsedName.Group == nil {
		groupName = "core"
	} else {
		groupName = *parsedName.Group
	}

	group, ok := root.groups[groupName]
	if !ok {
		group = newGroup(groupName, root)
		root.groups[groupName] = group
	}

	versionedAPI, ok := group.versionedAPIs[*parsedName.Version]
	if !ok {
		versionedAPI = newVersionedAPI(*parsedName.Version, group)
		group.versionedAPIs[*parsedName.Version] = versionedAPI
	}

	apiObject, ok := versionedAPI.apiObjects[parsedName.Kind]
	if ok {
		log.Fatalf("Duplicate object kinds with name '%s'", parsedName.Unparse())
	}
	apiObject = newAPIObject(parsedName.Kind, versionedAPI, def)
	versionedAPI.apiObjects[parsedName.Kind] = apiObject
	return apiObject, nil
}

func (root *root) getAPIObject(
	parsedName *kubespec.ParsedDefinitionName,
) (*apiObject, error) {
	if parsedName.Version == nil {
		return nil, fmt.Errorf(
			"Can't make API object from name with nil version in path: '%s'",
			parsedName.Unparse())
	}

	var groupName kubespec.GroupName
	if parsedName.Group == nil {
		groupName = "core"
	} else {
		groupName = *parsedName.Group
	}

	group, ok := root.groups[groupName]
	if !ok {
		return nil, fmt.Errorf(
			"Could not retrieve object, group in path '%s' doesn't exist",
			parsedName.Unparse())
	}

	versionedAPI, ok := group.versionedAPIs[*parsedName.Version]
	if !ok {
		return nil, fmt.Errorf(
			"Could not retrieve object, versioned API in path '%s' doesn't exist",
			parsedName.Unparse())
	}

	if apiObject, ok := versionedAPI.apiObjects[parsedName.Kind]; ok {
		return apiObject, nil
	}
	return nil, fmt.Errorf(
		"Could not retrieve object, kind in path '%s' doesn't exist",
		parsedName.Unparse())
}

//-----------------------------------------------------------------------------
// Group.
//-----------------------------------------------------------------------------

// `group` is an abstract representation of a Kubernetes API group
// (e.g., apps, extensions, core), which can be emitted as Jsonnet
// code using the `emit` method.
//
// `group` contains a set of versioned APIs (e.g., v1, v1beta1, etc.),
// though the logic for creating them is handled largely by `root`.
type group struct {
	name          kubespec.GroupName // e.g., core, apps, extensions.
	versionedAPIs versionedAPISet    // e.g., v1, v1beta1.
	parent        *root
}
type groupSet map[kubespec.GroupName]*group
type groupSlice []*group

func newGroup(name kubespec.GroupName, parent *root) *group {
	return &group{
		name:          name,
		versionedAPIs: make(versionedAPISet),
		parent:        parent,
	}
}

func (group *group) root() *root {
	return group.parent
}

func (group *group) emit(m *indentWriter) {
	k8sVersion := group.root().spec.Info.Version
	mixinName := jsonnet.RewriteAsIdentifier(k8sVersion, group.name)
	line := fmt.Sprintf("%s:: {", mixinName)
	m.writeLine(line)
	m.indent()

	// Emit in sorted order so that we can diff the output.
	for _, versioned := range group.versionedAPIs.toSortedSlice() {
		versioned.emit(m)
	}

	m.dedent()
	m.writeLine("},")
}

func (gs groupSet) toSortedSlice() groupSlice {
	groups := groupSlice{}
	for _, group := range gs {
		groups = append(groups, group)
	}
	sort.Slice(groups, func(i, j int) bool {
		return groups[i].name < groups[j].name
	})
	return groups
}

//-----------------------------------------------------------------------------
// Versioned API.
//-----------------------------------------------------------------------------

// `versionedAPI` is an abstract representation of a version of a
// Kubernetes API group (e.g., apps.v1beta1, extensions.v1beta1,
// core.v1), which can be emitted as Jsonnet code using the `emit`
// method.
//
// `versionedAPI` contains a set of API objects (e.g., v1.Container,
// v1beta1.Deployment, etc.), though the logic for creating them is
// handled largely by `root`.
type versionedAPI struct {
	version    kubespec.VersionString // version string, e.g., v1, v1beta1.
	apiObjects apiObjectSet           // set of objects, e.g, v1.Container.
	parent     *group
}
type versionedAPISet map[kubespec.VersionString]*versionedAPI
type versionedAPISlice []*versionedAPI

func newVersionedAPI(
	version kubespec.VersionString, parent *group,
) *versionedAPI {
	return &versionedAPI{
		version:    version,
		apiObjects: make(apiObjectSet),
		parent:     parent,
	}
}

func (va *versionedAPI) root() *root {
	return va.parent.parent
}

func (va *versionedAPI) emit(m *indentWriter) {
	// NOTE: Do not need to call `jsonnet.RewriteAsIdentifier`.
	line := fmt.Sprintf("%s:: {", va.version)
	m.writeLine(line)
	m.indent()

	gn := va.parent.name
	if gn == "core" {
		m.writeLine(fmt.Sprintf(
			"local apiVersion = {apiVersion: \"%s\"},", va.version))
	} else {
		m.writeLine(fmt.Sprintf(
			"local apiVersion = {apiVersion: \"%s/%s\"},", gn, va.version))
	}

	// Emit in sorted order so that we can diff the output.
	for _, object := range va.apiObjects.toSortedSlice() {
		if !object.isTopLevel {
			// continue
		}
		object.emit(m)
	}

	m.dedent()
	m.writeLine("},")
}

func (vas versionedAPISet) toSortedSlice() versionedAPISlice {
	versionedAPIs := versionedAPISlice{}
	for _, va := range vas {
		versionedAPIs = append(versionedAPIs, va)
	}
	sort.Slice(versionedAPIs, func(i, j int) bool {
		return versionedAPIs[i].version < versionedAPIs[j].version
	})
	return versionedAPIs
}

//-----------------------------------------------------------------------------
// API object.
//-----------------------------------------------------------------------------

// `apiObject` is an abstract representation of a Kubernetes API
// object (e.g., v1.Container, v1beta1.Deployment), which can be
// emitted as Jsonnet code using the `emit` method.
//
// `apiObject` contains a set of property methods and mixins which
// formulate the basis of much of ksonnet-lib's programming surface.
// The logic for creating them is handled largely by `root`.
type apiObject struct {
	name            kubespec.ObjectKind // e.g., `Container` in `v1.Container`
	propertyMethods propertyMethodSet   // e.g., container.image, container.env
	comments        comments
	parent          *versionedAPI
	isTopLevel      bool
}
type apiObjectSet map[kubespec.ObjectKind]*apiObject
type apiObjectSlice []*apiObject

func newAPIObject(
	name kubespec.ObjectKind, parent *versionedAPI, def *kubespec.SchemaDefinition,
) *apiObject {
	isTopLevel := len(def.TopLevelSpecs) > 0
	comments := newComments(def.Description)
	return &apiObject{
		name:            name,
		propertyMethods: make(propertyMethodSet),
		comments:        comments,
		parent:          parent,
		isTopLevel:      isTopLevel,
	}
}

func (ao *apiObject) root() *root {
	return ao.parent.parent.parent
}

func (ao *apiObject) emit(m *indentWriter) {
	k8sVersion := ao.root().spec.Info.Version
	jsonnetName := kubespec.ObjectKind(
		jsonnet.RewriteAsIdentifier(k8sVersion, ao.name))
	if _, ok := ao.parent.apiObjects[jsonnetName]; ok {
		log.Fatalf(
			"Tried to lowercase first character of object kind '%s', but lowercase name was already present in version '%s'",
			jsonnetName,
			ao.parent.version)
	}

	ao.comments.emit(m)

	line := fmt.Sprintf("%s:: {", jsonnetName)
	m.writeLine(line)
	m.indent()

	// NOTE: It is important to NOT capitalize `ao.name` here.
	m.writeLine(fmt.Sprintf("local kind = {kind: \"%s\"},", ao.name))
	ao.emitConstructor(m)

	for _, pm := range ao.propertyMethods.sortAndFilterBlacklisted() {
		// Skip special properties and fields that `$ref` another API
		// object type, since those will go in the `mixin` namespace.
		if isSpecialProperty(pm.name) || pm.Ref != nil {
			continue
		}
		pm.emit(m)
	}

	// Emit the properties that `$ref` another API object type in the
	// `mixin:: {` namespace.
	m.writeLine("mixin:: {")
	m.indent()

	for _, pm := range ao.propertyMethods.sortAndFilterBlacklisted() {
		// TODO: Emit mixin code also for arrays whose elements are
		// `$ref`.
		if pm.Ref == nil {
			continue
		}
		pm.emit(m)
	}

	m.dedent()
	m.writeLine("},")

	m.dedent()
	m.writeLine("},")
}

// `emitAsRefMixins` recursively emits an API object as a collection
// of mixin methods, particularly when another API object has a
// property that uses `$ref` to reference the current API object.
//
// For example, `v1beta1.Deployment` has a field, `spec`, which is of
// type `v1beta1.DeploymentSpec`. In this case, we'd like to
// recursively capture all the properties of `v1beta1.DeploymentSpec`
// and create mixin methods, so that we can do something like
// `someDeployment + deployment.mixin.spec.minReadySeconds(3)`.
func (ao *apiObject) emitAsRefMixins(
	m *indentWriter, pm *propertyMethod, parentMixinName *string,
) {
	k8sVersion := ao.root().spec.Info.Version
	functionName := jsonnet.RewriteAsIdentifier(k8sVersion, pm.name)
	paramName := jsonnet.RewriteAsFuncParam(k8sVersion, pm.name)
	fieldName := jsonnet.RewriteAsFieldKey(pm.name)
	mixinName := fmt.Sprintf("__%sMixin", functionName)
	var mixinText string
	if parentMixinName == nil {
		mixinText = fmt.Sprintf(
			"local %s(%s) = {%s+: %s},", mixinName, paramName, fieldName, paramName)
	} else {
		mixinText = fmt.Sprintf(
			"local %s(%s) = %s({%s+: %s}),",
			mixinName, paramName, *parentMixinName, fieldName, paramName)
	}

	if _, ok := ao.parent.apiObjects[kubespec.ObjectKind(functionName)]; ok {
		log.Fatalf(
			"Tried to lowercase first character of object kind '%s', but lowercase name was already present in version '%s'",
			functionName,
			ao.parent.version)
	}

	// NOTE: Comments are emitted by `propertyMethod#emit`, before we
	// call this method.

	line := fmt.Sprintf("%s:: {", functionName)
	m.writeLine(line)
	m.indent()

	m.writeLine(mixinText)

	for _, pm := range ao.propertyMethods.sortAndFilterBlacklisted() {
		if isSpecialProperty(pm.name) {
			continue
		}
		pm.emitAsRefMixin(m, mixinName)
	}

	m.dedent()
	m.writeLine("},")
}

func (ao *apiObject) emitConstructor(m *indentWriter) {
	// if dm, ok := ao.propertyMethods["default"]; ok {
	// 	log.Fatalf(
	// 		"Attempted to create constructor, but 'default' property already existed at '%s'",
	// 		dm.path)
	// }

	if ao.isTopLevel {
		m.writeLine("default():: apiVersion + kind,")
	} else {
		m.writeLine("default():: {},")
	}
}

func (aos apiObjectSet) toSortedSlice() apiObjectSlice {
	apiObjects := apiObjectSlice{}
	for _, apiObject := range aos {
		apiObjects = append(apiObjects, apiObject)
	}
	sort.Slice(apiObjects, func(i, j int) bool {
		return apiObjects[i].name < apiObjects[j].name
	})
	return apiObjects
}

//-----------------------------------------------------------------------------
// Property method.
//-----------------------------------------------------------------------------

// `propertyMethod` is an abstract representation of a ksonnet-lib's
// property methods, which can be emitted as Jsonnet code using the
// `emit` method.
//
// For example, ksonnet-lib exposes many functions such as
// `v1.container.image`, which can be added together with the `+`
// operator to construct a complete image. `propertyMethod` is an
// abstract representation of these so-called "property methods".
//
// `propertyMethod` contains the name of the property given in the
// `apiObject` that is its parent (for example, `Deployment` has a
// field called `containers`, which is an array of `v1.Container`), as
// well as the `kubespec.PropertyName`, which contains information
// required to generate the Jsonnet code.
//
// The logic for creating them is handled largely by `root`.
type propertyMethod struct {
	*kubespec.Property
	name     kubespec.PropertyName // e.g., image in container.image.
	path     kubespec.DefinitionName
	comments comments
	parent   *apiObject
}
type propertyMethodSet map[kubespec.PropertyName]*propertyMethod
type propertyMethodSlice []*propertyMethod

func newPropertyMethod(
	name kubespec.PropertyName, path kubespec.DefinitionName,
	property *kubespec.Property, parent *apiObject,
) *propertyMethod {
	comments := newComments(property.Description)
	return &propertyMethod{
		Property: property,
		name:     name,
		path:     path,
		comments: comments,
		parent:   parent,
	}
}

func (pm *propertyMethod) root() *root {
	return pm.parent.parent.parent.parent
}

func (pm *propertyMethod) emit(m *indentWriter) {
	pm.emitHelper(m, nil)
}

// `emitAsRefMixin` will emit a property as a mixin method, so that it
// can be "mixed in" to alter an existing object.
//
// For example if we have a fully-formed deployment object,
// `someDeployment`, we'd like to be able to do something like
// `someDeployment + deployment.mixin.spec.minReadySeconds(3)` to "mix
// in" a change to the `spec.minReadySeconds` field.
//
// This method will take the `propertyMethod`, which specifies a
// property method, and use it to emit such a "mixin method".
func (pm *propertyMethod) emitAsRefMixin(
	m *indentWriter, parentMixinName string,
) {
	pm.emitHelper(m, &parentMixinName)
}

// `emitHelper` emits the Jsonnet program text for a `propertyMethod`,
// handling both the case that it's a mixin (i.e., `parentMixinName !=
// nil`), and the case that it's a "normal", non-mixin property method
// (i.e., `parentMixinName == nil`).
//
// NOTE: To get `emitHelper` to emit this property as a mixin, it is
// REQUIRED for `parentMixinName` to be non-nil; likewise, to get
// `emitHelper` to emit this property as a normal, non-mixin property
// method, it is necessary for `parentMixinName == nil`.
func (pm *propertyMethod) emitHelper(
	m *indentWriter, parentMixinName *string,
) {
	pm.comments.emit(m)

	k8sVersion := pm.root().spec.Info.Version
	functionName := jsonnet.RewriteAsIdentifier(k8sVersion, pm.name)
	paramName := jsonnet.RewriteAsFuncParam(k8sVersion, pm.name)
	fieldName := jsonnet.RewriteAsFieldKey(pm.name)
	signature := fmt.Sprintf("%s(%s)::", functionName, paramName)

	if pm.Ref != nil {
		parsedRefPath := pm.Ref.Name().Parse()
		apiObject, err := pm.root().getAPIObject(parsedRefPath)
		if err != nil {
			return
			// log.Fatalf("Failed to emit ref mixin:\n%v", err)
		}
		apiObject.emitAsRefMixins(m, pm, parentMixinName)
	} else if pm.Type != nil {
		paramType := *pm.Type

		var body string
		switch paramType {
		case "array":
			if parentMixinName == nil {
				body = fmt.Sprintf(
					"if std.type(%s) == \"array\" then {%s+: %s} else {%s: [%s]}",
					paramName, fieldName, paramName, fieldName, paramName,
				)
			} else {
				body = fmt.Sprintf(
					"if std.type(%s) == \"array\" then %s({%s+: %s}) else %s({%s: [%s]})",
					paramName, *parentMixinName, fieldName, paramName, *parentMixinName,
					fieldName, paramName,
				)
			}
		case "integer", "string", "boolean":
			if parentMixinName == nil {
				body = fmt.Sprintf("{%s: %s}", fieldName, paramName)
			} else {
				body = fmt.Sprintf("%s({%s: %s})", *parentMixinName, fieldName, paramName)
			}
		case "object":
			if parentMixinName == nil {
				body = fmt.Sprintf("{%s+: %s}", fieldName, paramName)
			} else {
				body = fmt.Sprintf("%s({%s+: %s})", *parentMixinName, fieldName, paramName)
			}
		default:
			log.Fatalf("Unrecognized type '%s'", paramType)
		}

		line := fmt.Sprintf("%s %s,", signature, body)
		m.writeLine(line)
	} else {
		log.Fatalf("Neither a type nor a ref")
	}
}

func (aos propertyMethodSet) sortAndFilterBlacklisted() propertyMethodSlice {
	propertyMethods := propertyMethodSlice{}
	for _, pm := range aos {
		k8sVersion := pm.root().spec.Info.Version
		if kubeversion.IsBlacklistedProperty(k8sVersion, pm.path, pm.name) {
			continue
		}
		propertyMethods = append(propertyMethods, pm)
	}
	sort.Slice(propertyMethods, func(i, j int) bool {
		return propertyMethods[i].name < propertyMethods[j].name
	})
	return propertyMethods
}

//-----------------------------------------------------------------------------
// Comments.
//-----------------------------------------------------------------------------

type comments []string

func newComments(text string) comments {
	return strings.Split(text, "\n")
}

func (cs *comments) emit(m *indentWriter) {
	for _, comment := range *cs {
		if comment == "" {
			// Don't create trailing space if comment is empty.
			m.writeLine("//")
		} else {
			m.writeLine(fmt.Sprintf("// %s", comment))
		}
	}
}
